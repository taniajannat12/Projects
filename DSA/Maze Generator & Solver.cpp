#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <ctime>
using namespace std;
int width, height;
int dx[] = {0, 1, 0, -1};   // Up, Right, Down, Left
int dy[] = {-1, 0, 1, 0};
struct cell {
bool wall[4] = {true, true, true, true};
bool visited = false;};
vector<vector<cell>> maze;
vector<vector<cell>> autoGeneratedMazeBackup; // auto generated maze backup
bool isvalid(int x, int y) {
return (x >= 0 && x < width && y >= 0 && y < height);}
// User Input Maze
void inputMazeFromUser() {
cout << "Enter maze size (width height): ";
cin >> width >> height;
maze.assign(height, vector<cell>(width));
cout << "Enter each cell walls as number (0-15), bitwise: Up=1, Right=2, Down=4, Left=8\n";
for (int y = 0; y < height; y++) {


        cout << "Row " << y+1 << ": ";
        for (int x = 0; x < width; x++) {
            int w; cin >> w;
            while (w < 0 || w > 15) {
                cout << "Invalid! Enter 0 to 15: "; cin >> w;}
            maze[y][x].wall[0] = (w & 1);
            maze[y][x].wall[1] = (w & 2);
            maze[y][x].wall[2] = (w & 4);
            maze[y][x].wall[3] = (w & 8);}}}
void removeWalls(int x1, int y1, int x2, int y2) {
    if (x1 == x2) {
        if (y1 < y2) { // down
            maze[y1][x1].wall[2] = false;
            maze[y2][x2].wall[0] = false;
        } else { // up
            maze[y1][x1].wall[0] = false;
            maze[y2][x2].wall[2] = false;}
    } else if (y1 == y2) {
        if (x1 < x2) { // right
            maze[y1][x1].wall[1] = false;
            maze[y2][x2].wall[3] = false;
        } else { // left
            maze[y1][x1].wall[3] = false;
            maze[y2][x2].wall[1] = false;}}}
// Generate maze using DFS backtracking
void generateMaze(int x, int y) {
    maze[y][x].visited = true;


    int dirs[] = {0,1,2,3};
    for (int i=3; i>0; i--) {
        int j = rand() % (i+1);
        swap(dirs[i], dirs[j]);}
    for (int i=0; i<4; i++) {
        int dir = dirs[i];
        int nx = x + dx[dir];
        int ny = y + dy[dir];
        if (isvalid(nx, ny) && !maze[ny][nx].visited) {
            removeWalls(x, y, nx, ny);
            generateMaze(nx, ny);}}}
// Print maze
void printMaze() {
    cout << "\n*******  My  Maze  ********\n";
    for (int y=0; y<height; y++) {
        // Print top walls
        for (int x=0; x<width; x++) {
            cout << "+";
            cout << (maze[y][x].wall[0] ? "---" : "   ");}
        cout << "+\n";
        // Print left walls and cell contents
        for (int x=0; x<width; x++) {
            cout << (maze[y][x].wall[3] ? "|" : " ");
            if (y == 0 && x == 0) cout << " S ";
            else if (y == height-1 && x == width-1) cout << " E ";
            else cout << "   ";}
        cout << "|\n";}



    for (int x=0; x<width; x++) cout << "+---";
    cout << "+\n";}

// Insert wall
void insertWall(int x, int y, int dir) {
    if (!isvalid(x,y)) {
        cout << "Invalid cell!\n";
        return;}
    maze[y][x].wall[dir] = true;
    int nx = x + dx[dir];
    int ny = y + dy[dir];
    if (isvalid(nx, ny)) {
        int opp = (dir + 2) % 4;
        maze[ny][nx].wall[opp] = true;}
    cout << "Wall inserted at (" << x << "," << y << ") towards ";
    if(dir == 0) cout << "Up (dx=0, dy=-1)";
    else if(dir == 1) cout << "Right (dx=1, dy=0)";
    else if(dir == 2) cout << "Down (dx=0, dy=1)";
    else cout << "Left (dx=-1, dy=0)";
    cout << "\n";}
// Delete wall
void deleteWall(int x, int y, int dir) {
    if (!isvalid(x,y)) {
        cout << "Invalid cell!\n";
        return;}
    maze[y][x].wall[dir] = false;
    int nx = x + dx[dir];



    int ny = y + dy[dir];
    if (isvalid(nx, ny)) {
        int opp = (dir + 2) % 4;
        maze[ny][nx].wall[opp] = false;}
    cout << "Wall deleted at (" << x << "," << y << ") towards ";
    if(dir == 0) cout << "Up (dx=0, dy=-1)";
    else if(dir == 1) cout << "Right (dx=1, dy=0)";
    else if(dir == 2) cout << "Down (dx=0, dy=1)";
    else cout << "Left (dx=-1, dy=0)";
    cout << "\n";}
// Search cell walls
void searchCell(int x, int y) {
    if (!isvalid(x,y)) {
        cout << "Invalid cell!\n";
        return;}
    cout << "Cell (" << x << "," << y << ") walls: ";
    cout << "Up=" << maze[y][x].wall[0] << ", ";
    cout << "Right=" << maze[y][x].wall[1] << ", ";
    cout << "Down=" << maze[y][x].wall[2] << ", ";
    cout << "Left=" << maze[y][x].wall[3] << "\n";}
// Maze Solver with BFS + path reconstruction
struct point { int x,y; };
bool solveMazeWithPath(vector<point> &path) {
    vector<vector<bool>> visited(height, vector<bool>(width, false));
    vector<vector<point>> parent(height, vector<point>(width, {-1,-1}));
    queue<point> q;
    q.push({0,0});



    visited[0][0] = true;
    bool found = false;

    while (!q.empty()) {
        point p = q.front(); q.pop();
        int x = p.x, y = p.y;
        if (x == width-1 && y == height-1) {
            found = true;
            path.clear();
            for (point cur = p; cur.x != -1 && cur.y != -1; cur = parent[cur.y][cur.x])
                path.push_back(cur);
            reverse(path.begin(), path.end());
            break;}
        for (int dir=0; dir<4; dir++) {
            int nx = x + dx[dir];
            int ny = y + dy[dir];
            if (isvalid(nx, ny) && !visited[ny][nx] && !maze[y][x].wall[dir]) {
                visited[ny][nx] = true;
                parent[ny][nx] = {x,y};
                q.push({nx, ny});}}}
    return found;}
// Print maze with solution path
void printMazeWithPath(const vector<point> &path) {
    cout << "\n#####  Maze with Solution Path  #####\n";
    vector<vector<bool>> isPath(height, vector<bool>(width, false));
    for (auto &p : path) isPath[p.y][p.x] = true;
    for (int y=0; y<height; y++) {


        for (int x=0; x<width; x++) {
            cout << "+";
            cout << (maze[y][x].wall[0] ? "---" : "   ");}
        cout << "+\n";
        for (int x=0; x<width; x++) {
            cout << (maze[y][x].wall[3] ? "|" : " ");
            if (y == 0 && x == 0) cout << " S ";
            else if (y == height-1 && x == width-1) cout << " E ";
            else if (isPath[y][x]) cout << " . ";
            else cout << "   ";}
        cout << "|\n";}
    for (int x=0; x<width; x++) cout << "+---";
    cout << "+\n";}
int main() {
    srand(time(0));
    cout << "Choose input method:\n1. User Input Maze\n2. Auto Generate Maze\nChoice: ";
    int choice; cin >> choice;
    vector<point> solutionPath;
    bool mazeSolved = false;
    bool allowEdit = false;
    if (choice == 1) {
        inputMazeFromUser();
        allowEdit = true;
        mazeSolved = solveMazeWithPath(solutionPath);
        if (!mazeSolved) {
            cout << "Maze could not be solved with given input.\n";
            cout << "Showing current maze:\n";


        } else {
            cout << "Maze solved!\n";}
        printMaze();
    } else {
        // Auto generate
        cout << "Enter maze size (width height): ";
        cin >> width >> height;
        maze.assign(height, vector<cell>(width));
        generateMaze(0,0);
        // Backup original auto maze to show if needed
        autoGeneratedMazeBackup = maze;
        mazeSolved = solveMazeWithPath(solutionPath);
        cout << "\nAuto generated maze:\n";
        printMaze();
        if (mazeSolved) cout << "Maze is SOLVED.\n";
        else cout << "Maze is NOT solved or unsolvable.\n";}
    while (true) {
        cout << "\nMenu:\n";
        if (allowEdit) {
            cout << "1. Insert Wall\n2. Delete Wall\n3. Search Cell\n";}
        cout << "4. Solve Maze\n5. Show Solution Path\n6. Exit\nChoice: ";
        int ch; cin >> ch;
        if (ch == 1 && allowEdit) {
            int x,y,dir;
            cout << "Enter cell x y direction(0=Up,1=Right,2=Down,3=Left): ";
            cin >> x >> y >> dir;
            if (!isvalid(x,y) || dir < 0 || dir > 3) {


                cout << "Invalid input!\n";
                continue;}
            insertWall(x,y,dir);
            mazeSolved = solveMazeWithPath(solutionPath);
            if (mazeSolved) cout << "After insertion, Maze is SOLVED.\n";
            else cout << "After insertion, Maze is NOT solved or unsolvable.\n";
            printMaze();
        } else if (ch == 2 && allowEdit) {
            int x,y,dir;
            cout << "Enter cell x y direction(0=Up,1=Right,2=Down,3=Left): ";
            cin >> x >> y >> dir;
            if (!isvalid(x,y) || dir < 0 || dir > 3) {
                cout << "Invalid input!\n";
                continue;}
            deleteWall(x,y,dir);
            mazeSolved = solveMazeWithPath(solutionPath);
            if (mazeSolved) cout << "After deletion, Maze is SOLVED.\n";
            else cout << "After deletion, Maze is NOT solved or unsolvable.\n";
            printMaze();
        } else if (ch == 3 && allowEdit) { int x,y;
            cout << "Enter cell x y to search walls: ";
            cin >> x >> y;
            if (!isvalid(x,y)) {
                cout << "Invalid cell!\n"; continue;}
            searchCell(x,y);
            printMaze();
            mazeSolved = solveMazeWithPath(solutionPath);

            if (mazeSolved) cout << "Maze is currently SOLVED.\n";
            else cout << "Maze is NOT solved yet or unsolvable.\n";
        } else if (ch == 4) {
            mazeSolved = solveMazeWithPath(solutionPath);
            if (mazeSolved) cout << "Maze solved successfully!\n";
            else cout << "Maze is NOT solved or unsolvable.\n";
        } else if (ch == 5) {
            if (!mazeSolved) cout << "Solve the maze first (option 4).\n";
            else printMazeWithPath(solutionPath);
        } else if (ch == 6) {
            cout << "Exiting...\n";
            break;
        } else {
            cout << "Invalid choice!\n";}}}

